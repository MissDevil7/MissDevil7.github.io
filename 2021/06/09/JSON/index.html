<!DOCTYPE html>
<html>
    <!-- Head -->
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="Devil">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">

    <!-- Page Title -->
    
        <title>JSON | Miss.Devil&#39;s hexo</title>
    
    <link rel="icon" href="/img/avatar-default.png">
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    
    
<script src="/js/script.js"></script>

    
<link rel="stylesheet" href="/css/style.css">

    
    <style>
        .deactiveColor{
            color: #37474f;
        }
        .activeColor{
            color: #006064;
        }
        a:hover{
            color: #006064;
        }
        .header-btn{
            color: #37474f;
        }
        
        .post-content img{
            margin: 50px auto;
        }
        
    </style>
<meta name="generator" content="Hexo 5.2.0"></head>
    <body>
        <div class="container">

            <!-- Top Anchor -->
            <div id="top"></div>

            <!-- Header -->
            <header class="header-wrapper">
    <div class="header-title-wrapper">
        <!-- Page Title -->
        <p class="header-title">
             
                
                    JSON
                
            
        </p>  
    </div>    

    
        <!-- Division Line -->
        <div class="division"></div> 
    
    
    <div class="header-detail">
        <!-- Header Button -->
        <div class="header-btn-wrapper">
            
                <span>
                    <a class="home-btn header-btn" href="/" title="homepage"><i class="fa fa-home"></i></a>
                </span>

                
                    <span>
                        <a class="catalog-btn header-btn"><i class="fa fa-list-ul"></i></a>
                    </span>
                
            
        </div>
    </div>
</header>

            <!-- Main -->
            <main>
                <article class="post-wrapper">
    

    
        <!-- Article Catalog -->
        <div class="catalog-dropdown col-xs-12 col-sm-12">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">一、语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">1、简单值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2、对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">3、数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">二、解析与序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JSON%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">1、JSON对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%89%E9%A1%B9"><span class="toc-number">2.2.</span> <span class="toc-text">2、序列化选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E7%BB%93%E6%9E%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">过滤结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%A9%E8%BF%9B"><span class="toc-number">2.2.2.</span> <span class="toc-text">字符串缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toJSON-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">toJSON()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E6%9E%90%E9%80%89%E9%A1%B9"><span class="toc-number">2.3.</span> <span class="toc-text">3、解析选项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">三、小结</span></a></li></ol>
        </div>
    

    
        <!--For now, Lightbox Only Show in Post Layout -->
        

        
        
    

    

    <!-- Article Content -->
    <div class="post-content">
        <blockquote>
<p>理解JSON最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON不属于JavaScript，它们只是拥有相同的语法而已。JSON也不是只能在JavaScript中使用，它是一种通用数据格式。很多语言都有解析和序列化JSON的内置能力。</p>
</blockquote>
<h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><p>JSON语法支持表示3种类型的值。</p>
<ul>
<li>简单值：字符串、数值、布尔值和null可以在JSON中出现，就像在JavaScript中一样。特殊值undefined不可以。</li>
<li>对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。</li>
<li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。</li>
</ul>
<p>JSON没有变量、函数或对象实例的概念。JSON的所有记号都只为表示结构化数据，虽然它借用了JavaScript的语法，但是千万不要把它跟JavaScript语言混淆。</p>
<h2 id="1、简单值"><a href="#1、简单值" class="headerlink" title="1、简单值"></a>1、简单值</h2><p>JavaScript字符串与JSON字符串的主要区别是，JSON字符串必须使用双引号（单引号会导致语法错误）。<br>布尔值和null本身也是有效的JSON值。不过，实践中更多使用JSON表示比较复杂的数据结构，其中会包含简单值。</p>
<h2 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h2><p>对象使用与JavaScript对象字面量略为不同的方式表示。以下是JavaScript中的对象字面量：</p>
<pre><code class="javascript">let person = &#123;
     name: &quot;Nicholas&quot;,
     age: 29
&#125;;</code></pre>
<p>虽然这对JavaScript开发者来说是标准的对象字面量，但JSON中的对象必须使用双引号把属性名包围起来。下面的代码与前面的代码是一样的：</p>
<pre><code class="javascript">let object = &#123;
     &quot;name&quot;: &quot;Nicholas&quot;,
     &quot;age&quot; : 29
&#125;;</code></pre>
<p>而用JSON表示相同的对象的语法是：</p>
<pre><code class="javascript">&#123;
     &quot;name&quot;: &quot;Nicholas&quot;,
     &quot;age&quot;: 29
&#125;</code></pre>
<ul>
<li>与JavaScript对象字面量相比，JSON主要有两处不同。首先，没有变量声明（JSON中没有变量）。其次，最后没有分号（不需要，因为不是JavaScript语句）。同样，用引号将属性名包围起来才是有效的JSON。</li>
</ul>
<p>属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象，比如：</p>
<pre><code class="javascript">&#123;
     &quot;name&quot;: &quot;Nicholas&quot;,
     &quot;age&quot;: 29,
     &quot;school&quot;: &#123;
        &quot;name&quot;: &quot;Merrimack College&quot;,
        &quot;location&quot;: &quot;North Andover, MA&quot;
        &#125;
&#125;</code></pre>
<p>这个例子在顶级对象中又嵌入了学校相关的信息。即使整个JSON对象中有两个属性都叫”name”，但它们属于两个不同的对象，因此是允许的。<strong>同一个对象中不允许出现两个相同的属性。</strong><br>与JavaScript不同，JSON中的<strong>对象属性名必须始终带双引号</strong>。手动编写JSON时漏掉这些双引号或使用单引<br>号是常见错误。</p>
<h2 id="3、数组"><a href="#3、数组" class="headerlink" title="3、数组"></a>3、数组</h2><p>JSON的第二种复杂数据类型是数组。数组在JSON中使用JavaScript的数组字面量形式表示。例如，以下是一个JavaScript数组：</p>
<pre><code class="javascript">let values = [25, &quot;hi&quot;, true];</code></pre>
<p>在JSON中可以使用类似语法表示相同的数组：</p>
<pre><code class="javascript">[25, &quot;hi&quot;, true]</code></pre>
<p>同样，这里<strong>没有变量，也没有分号</strong>。数组和对象可以组合使用，以表示更加复杂的数据结构，比如：</p>
<pre><code class="javascript">[
 &#123;
     &quot;title&quot;: &quot;Professional JavaScript&quot;,
     &quot;authors&quot;: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     &quot;edition&quot;: 4,
     &quot;year&quot;: 2017
  &#125;,
 &#123;
     &quot;title&quot;: &quot;Professional JavaScript&quot;,
     &quot;authors&quot;: [
         &quot;Nicholas C. Zakas&quot;
     ],
     &quot;edition&quot;: 3,
     &quot;year&quot;: 2011
 &#125;,
 &#123;
     &quot;title&quot;: &quot;Professional JavaScript&quot;,
     &quot;authors&quot;: [
         &quot;Nicholas C. Zakas&quot;
     ],
     &quot;edition&quot;: 2,
     &quot;year&quot;: 2009
 &#125;,
 &#123;
     &quot;title&quot;: &quot;Professional Ajax&quot;,
     &quot;authors&quot;: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Jeremy McPeak&quot;,
         &quot;Joe Fawcett&quot;
     ],
     &quot;edition&quot;: 1,
     &quot;year&quot;: 2007
 &#125;
 ]</code></pre>
<p>前面这个数组包含了很多表示书的对象。每个对象都包含一些键，其中一个是”authors”，对应的值也<br>是一个数组。对象和数组通常会作为JSON数组的顶级结构（尽管不是必需的），以便创建大型复杂数据结<br>构。</p>
<h1 id="二、解析与序列化"><a href="#二、解析与序列化" class="headerlink" title="二、解析与序列化"></a>二、解析与序列化</h1><p>JSON的迅速流行并不仅仅因为其语法与JavaScript类似，很大程度上还因为JSON可以直接被解析成可用的JavaScript对象。为此，JavaScript开发者可以非常方便地使用JSON数据。比如，前面例子中的JSON包含很多图书，通过如下代码就可以获取第三本书的书名：</p>
<pre><code class="javascript">books[2].title</code></pre>
<p>当然，以上代码假设把前面的数据结构保存在了变量books中。相比之下，遍历DOM结构就显得麻烦多了：</p>
<pre><code class="javascript">document.getElementsByTagName(&quot;book&quot;)[2].getAttribute(&quot;title&quot;);</code></pre>
<p>看看这些方法调用，就不难想象为什么JSON大受JavaScript开发者欢迎了。JSON出现之后就迅速成为了Web服务的事实序列化标准。</p>
<h2 id="1、JSON对象"><a href="#1、JSON对象" class="headerlink" title="1、JSON对象"></a>1、JSON对象</h2><p>JSON对象有两个方法：<strong>stringify()**和</strong>parse()**。<br>在简单的情况下，这两个方法分别可以将JavaScript序列化为JSON字符串，以及将JSON解析为原生JavaScript值。例如：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017
&#125;;
let jsonText = JSON.stringify(book);</code></pre>
<p>这个例子使用JSON.stringify()把一个JavaScript对象序列化为一个JSON字符串，保存在变量<br>jsonText中。默认情况下，JSON.stringify()会输出不包含空格或缩进的JSON字符串，因此<br>jsonText的值是这样的：</p>
<pre><code class="javascript">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;,&quot;Matt Frisbie&quot;],&quot;edition&quot;:4,&quot;year&quot;:2017&#125;</code></pre>
<p>在序列化JavaScript对象时，<strong>所有函数和原型成员都会有意地在结果中省略</strong>。此外，<strong>值为undefined的任何属性也会被跳过</strong>。最终得到的就是所有实例属性均为有效JSON数据类型的表示。<br>JSON字符串可以直接传给JSON.parse()，然后得到相应的JavaScript值。比如，可以使用以下代码创建与book对象类似的新对象：</p>
<pre><code class="javascript">let bookCopy = JSON.parse(jsonText);</code></pre>
<p>注意，book和bookCopy是两个完全不同的对象，没有任何关系。但是它们拥有相同的属性和值。<br>如果给JSON.parse()传入的JSON字符串无效，则会导致抛出错误。</p>
<h2 id="2、序列化选项"><a href="#2、序列化选项" class="headerlink" title="2、序列化选项"></a>2、序列化选项</h2><p>实际上，JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化JavaScript对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果JSON字符串的选项。单独或组合使用这些参数可以更好地控制JSON序列化。</p>
<h3 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h3><p>如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性。比如下面的例子：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017
&#125;;
let jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);</code></pre>
<p>在这个例子中，JSON.stringify()方法的第二个参数是一个包含两个字符串的数组：”title”和”edition”。它们对应着要序列化的对象中的属性，因此结果JSON字符串中只会包含这两个属性：</p>
<pre><code class="javascript">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:4&#125;</code></pre>
<p>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作。这个key始终是字符串，只是在值不属于某个键/值对时会是空字符串。</p>
<p>为了改变对象的序列化，返回的值就是相应key应该包含的结果。注意，返回undefined会导致属性被忽略。下面看一个例子：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017
&#125;;
let jsonText = JSON.stringify(book, (key, value) =&gt; &#123;
     switch(key) &#123;
         case &quot;authors&quot;:
             return value.join(&quot;,&quot;)
         case &quot;year&quot;:
             return 5000;
         case &quot;edition&quot;:
             return undefined;
         default:
             return value;
     &#125;
&#125;);</code></pre>
<p>这个函数基于键进行了过滤。如果键是”authors”，则将数组值转换为字符串；如果键是”year”，则将值设置为5000；如果键是”edition”，则返回undefined忽略该属性。最后一定要提供默认返回值，以便返回其他属性传入的值。第一次调用这个函数实际上会传入空字符串key，值是book对象。最终得到的JSON字符串是这样的：</p>
<pre><code class="javascript">&#123;&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas,MattFrisbie&quot;,&quot;year&quot;:5000&#125;</code></pre>
<p>注意，函数过滤器会应用到要序列化的对象所包含的所有对象，因此如果数组中包含多个具有这些属性的对象，则序列化之后每个对象都只会剩下上面这些属性。</p>
<h3 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h3><p>JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。例如，每级缩进4个空格，可以这样：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017
&#125;;
let jsonText = JSON.stringify(book, null, 4);</code></pre>
<p>这样得到的jsonText格式如下：</p>
<pre><code class="javascript">&#123;
     &quot;title&quot;: &quot;Professional JavaScript&quot;,
     &quot;authors&quot;: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     &quot;edition&quot;: 4,
     &quot;year&quot;: 2017 
&#125;</code></pre>
<p>注意，除了缩进，JSON.stringify()方法还为方便阅读插入了换行符。这个行为对于所有有效的缩进参数都会发生。（只缩进不换行也没什么用。）最大缩进值为10，大于10的值会自动设置为10。<br>如果缩进参数是一个字符串而非数值，那么JSON字符串中就会使用这个字符串而不是空格来缩进。使用字符串，也可以将缩进字符设置为Tab或任意字符，如两个连字符：</p>
<pre><code class="javascript">let jsonText = JSON.stringify(book, null, &quot;--&quot; );</code></pre>
<p>这样，jsonText的值会变成如下格式：</p>
<pre><code class="javascript">&#123;
--&quot;title&quot;: &quot;Professional JavaScript&quot;,
--&quot;authors&quot;: [
----&quot;Nicholas C. Zakas&quot;,
----&quot;Matt Frisbie&quot;
--],
--&quot;edition&quot;: 4,
--&quot;year&quot;: 2017
&#125;</code></pre>
<p>使用字符串时同样有10个字符的长度限制。如果字符串长度超过10，则会在第10个字符处截断。</p>
<h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON()方法"></a>toJSON()方法</h3><p>有时候，对象需要在JSON.stringify()之上自定义JSON序列化。此时，可以在要序列化的对象中添加toJSON()方法，序列化时会基于这个方法返回适当的JSON表示。事实上，原生Date对象就有一个toJSON()方法，能够自动将JavaScript的Date对象转换为ISO 8601日期字符串。<br>下面的对象为自定义序列化而添加了一个toJSON()方法：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017,
     toJSON: function() &#123;
         return this.title;
     &#125;
&#125;;
let jsonText = JSON.stringify(book);</code></pre>
<p>这里book对象中定义的toJSON()方法简单地返回了图书的书名（this.title）Professional JavaScript。</p>
<p>这个对象会被序列化为简单字符串而非对象。toJSON()方法可以返回任意序列化值，都可以起到相应的作用。如果对象被嵌入在另一个对象中，返回undefined会导致值变成null；或者如果是顶级对象，则本身就是undefined。</p>
<blockquote>
<p>注意，箭头函数不能用来定义toJSON()方法。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。</p>
</blockquote>
<p>toJSON()方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传给JSON.stringify()时会执行如下步骤。</p>
<ol>
<li>如果可以获取实际的值，则调用toJSON()方法获取实际的值，否则使用默认的序列化。</li>
<li>如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第(1)步返回的值。 </li>
<li>第(2)步返回的每个值都会相应地进行序列化。</li>
<li>如果提供了第三个参数，则相应地进行缩进。</li>
</ol>
<p>理解这个顺序有助于决定是创建toJSON()方法，还是使用过滤函数，抑或是两者都用。</p>
<h2 id="3、解析选项"><a href="#3、解析选项" class="headerlink" title="3、解析选项"></a>3、解析选项</h2><p>JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。为区别于传给JSON.stringify()的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。<br>如果还原函数返回undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为Date对象。例如：</p>
<pre><code class="javascript">let book = &#123;
     title: &quot;Professional JavaScript&quot;,
     authors: [
         &quot;Nicholas C. Zakas&quot;,
         &quot;Matt Frisbie&quot;
     ],
     edition: 4,
     year: 2017,
     releaseDate: new Date(2017, 11, 1)
&#125;;
let jsonText = JSON.stringify(book);
let bookCopy = JSON.parse(jsonText, (key, value) =&gt; key == &quot;releaseDate&quot; ? new Date(value) : value);
alert(bookCopy.releaseDate.getFullYear());</code></pre>
<p>以上代码在book对象中增加了releaseDate属性，是一个Date对象。这个对象在被序列化为JSON字符串后，又被重新解析为一个对象bookCopy。这里的还原函数会查找”releaseDate”键，如果找到就会根据它的日期字符串创建新的Date对象。得到的bookCopy.releaseDate属性又变回了Date对象，因此可以调用其getFullYear()方法。</p>
<h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>JSON是一种轻量级数据格式，可以方便地表示复杂数据结构。这个格式使用JavaScript语法的一个子集表示对象、数组、字符串、数值、布尔值和null。所有浏览器都已经原生支持全局JSON对象。<br>ECMAScript 5定义了原生JSON对象，用于将JavaScript对象序列化为JSON字符串，以及将JSON数组解析为JavaScript对象。JSON.stringify()和JSON.parse()方法分别用于实现这两种操作。这两个方法都有一些选项可以用来改变默认的行为，以实现过滤或修改流程。</p>
  
    </div> 

    
        <!-- Division Line -->
        <div class="division"></div> 
    

    <div class="post-info-wrapper">
            
                    <!-- Post Info -->
                    <p class="post-date">2021-06-09</p>
                    
                    
                        <p class="post-info-categories">
                            
                        </p>
                    

                    
            
    </div>
</article>


    

            </main>

            <!-- 'To Top' Btn-->
            
                <div id="to-top">
    <a href="#top" class="toTop">
        <i class="fa fa-pagelines"></i>
    </a>
</div>
            

            <!-- Footer -->
            
                <footer class="footer-wrapper col-xs-12 col-sm-12">
    <div class="footer-banner-wrapper">
        <p class="footer-banner">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/" title="Hexo">Hexo</a></p>
        <P class="footer-banner">Theme <a target="_blank" rel="noopener" href="https://github.com/Lonezj/hexo-theme-wind" title="Wind">wind</a></P>
    </div>
</footer>
            
        </div>

        <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css">
        <link rel="stylesheet" href="/css/google-prettify-monokai.css" type="text/css">
        <script src="//cdn.bootcss.com/prettify/r298/prettify.min.js" type="text/javascript"></script>
    </body>
</html>